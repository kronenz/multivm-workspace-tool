# ARCHIVED — Plan generated at .sisyphus/plans/ssh-terminal-grid.md

## Requirements (confirmed)
- **Feature 2 (SSH)**: Connect via key/password/ssh-config, connection pooling, keepalive 15s, error reporting, disconnect cleanup, auto-reconnect (3 attempts, backoff+jitter — implement but hook later)
- **Feature 3 (Terminal)**: xterm.js per pane, WebGL renderer (Canvas fallback), bidirectional IPC, 256-color/truecolor, 10K line scrollback, terminal resize → PTY, copy/paste
- **Feature 4 (Grid)**: CSS Grid, presets (1x1, 2x1, 2x2, 2x3, 3x3), pane status indicator, active focus border, layout toolbar
- **Integration**: Workset activation → grid layout → create terminals → SSH connect in parallel → cd + ai_cli_command

## Technical Decisions
- SSH lives in Rust Core (security boundary) — confirmed
- ssh2 crate (sync) bridged via tokio::task::spawn_blocking — confirmed
- Per-session reader thread emits Tauri events — confirmed
- IPC: `activate_workset`, `deactivate_workset`, `terminal_input`, `terminal_resize` — confirmed
- Events: `terminal-output-{session_id}` — confirmed
- Password: text input for now (OS keystore later) — confirmed

## Rust Modules
- `src-tauri/src/ssh/mod.rs` — SshConnectionManager
- `src-tauri/src/ssh/session.rs` — SshSession

## Frontend Changes
- index.html: grid container, layout toolbar
- main.ts: terminal management, grid rendering, workset activation
- styles.css: grid layout, terminal panes, toolbar

## Open Questions — RESOLVED
- Test strategy: **Tests-after**. Verify via cargo check / npm run build / cargo build --release.
- Frontend file organization: **Separate modules** (grid.ts, terminal.ts) — Metis guardrail G9.
- Grid presets: **Always available**. Handle connections < cells with empty placeholder panes.

## Research Findings
- **Rust backend**: lib.rs has 5 sync commands, workset/mod.rs is 420 lines well-structured. No ssh/ module exists.
- **Frontend**: main.ts is 642-line monolith. xterm.js packages in package.json but never imported.
- **Librarian**: xterm.js init order: FitAddon → open() → fit() → WebGL (catch → Canvas fallback). Use ResizeObserver + FitAddon.fit(). Base64 for binary IPC data. requestAnimationFrame batching for terminal writes.
- **SPIKE-2 patterns**: TcpStream::connect_timeout → Session::new → set_tcp_stream → handshake → userauth_pubkey_file → set_keepalive(true, 15) → channel_session → request_pty → read loop.

## Metis Review — Key Findings
1. Password MUST NOT be persisted to disk (NFR-12/13). Use runtime-only: prompt on activate, pass via IPC.
2. SshConfig auth EXCLUDED from this batch. Key + Password only.
3. Session IDs generated by Rust backend (UUID).
4. All new Tauri commands MUST be async (existing CRUD commands are sync — don't follow that pattern).
5. Frontend code in separate .ts files, not added to 642-line main.ts monolith.
6. Buffer terminal writes via requestAnimationFrame batching.
7. Handle connections.len() != rows*cols gracefully.
8. Each SSH session on std::thread (NOT tokio task) — ssh2 is not Send-safe across await points.
9. AppHandle.emit() from std::thread is valid (AppHandle is Send+Sync).
10. Drag-to-resize panes EXCLUDED. CSS Grid with equal fractions (1fr).
11. Auto-reconnect EXCLUDED (just emit disconnect status events).
12. Implement Drop on SshConnectionManager to send Shutdown to all workers.
13. xterm.css must be imported for proper rendering.
14. TCP connect timeout 10s to prevent activation stalling on unreachable hosts.
15. Debounce resize events (100ms).

## Scope Boundaries (Final)
- INCLUDE: SSH Key auth, SSH Password auth (runtime-only), Grid presets (1x1/2x1/2x2/2x3/3x3), xterm.js WebGL+Canvas, bidirectional IPC, workset activation flow
- EXCLUDE: SshConfig parsing, drag-to-resize, OS Keystore, auto-reconnect logic, pane content-type switching (all panes are terminals), unit tests
